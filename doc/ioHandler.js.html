<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>ioHandler.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="MEIdoc.html">MEIdoc</a><ul class='methods'><li data-type='method' style='display: none;'><a href="MEIdoc.html#addAnnotation">addAnnotation</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#addMeiElement">addMeiElement</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#addRevision">addRevision</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#appendToIdDictionary">appendToIdDictionary</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#doXPathOnDoc">doXPathOnDoc</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#getAnnotation">getAnnotation</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#getBlockByEventId">getBlockByEventId</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#getBlocksFromSections">getBlocksFromSections</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#initAnnotations">initAnnotations</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#initEventDict">initEventDict</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#preprocess">preprocess</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#proportionMultiplier">proportionMultiplier</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#renewBlob">renewBlob</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="alterate.html">alterate</a><ul class='methods'><li data-type='method' style='display: none;'><a href="alterate.html#.firstBeatAlteration">firstBeatAlteration</a></li><li data-type='method' style='display: none;'><a href="alterate.html#.midBeatAlteration">midBeatAlteration</a></li><li data-type='method' style='display: none;'><a href="alterate.html#.secondBeatAlteration">secondBeatAlteration</a></li><li data-type='method' style='display: none;'><a href="alterate.html#.thirdBeatAlteration">thirdBeatAlteration</a></li><li data-type='method' style='display: none;'><a href="alterate.html#~checkForGeneralAlteration">checkForGeneralAlteration</a></li></ul></li><li><a href="basic.html">basic</a><ul class='methods'><li data-type='method' style='display: none;'><a href="basic.html#.beatIndependentDurations">beatIndependentDurations</a></li><li data-type='method' style='display: none;'><a href="basic.html#~actOnColoration">actOnColoration</a></li><li data-type='method' style='display: none;'><a href="basic.html#~actOnDots">actOnDots</a></li><li data-type='method' style='display: none;'><a href="basic.html#~allUnalterableImperfectLevels">allUnalterableImperfectLevels</a></li><li data-type='method' style='display: none;'><a href="basic.html#~anteSim">anteSim</a></li><li data-type='method' style='display: none;'><a href="basic.html#~labelRests">labelRests</a></li><li data-type='method' style='display: none;'><a href="basic.html#~simplestAlterations">simplestAlterations</a></li></ul></li><li><a href="complexBeats.html">complexBeats</a><ul class='methods'><li data-type='method' style='display: none;'><a href="complexBeats.html#.complexAnalysis">complexAnalysis</a></li><li data-type='method' style='display: none;'><a href="complexBeats.html#~afterTheEasyBits">afterTheEasyBits</a></li></ul></li><li><a href="durIO.html">durIO</a><ul class='methods'><li data-type='method' style='display: none;'><a href="durIO.html#.readBlockFrom">readBlockFrom</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.readDur">readDur</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.readDurGes">readDurGes</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.readStartsAt">readStartsAt</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.setBeatPos">setBeatPos</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.setBreveBoundaries">setBreveBoundaries</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.setDurGesPerBlock">setDurGesPerBlock</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.setStartsAt">setStartsAt</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.windowDuration">windowDuration</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeAlteration">writeAlteration</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeComment">writeComment</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeCommentById">writeCommentById</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeDur">writeDur</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeDurGes">writeDurGes</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeDurWithRule">writeDurWithRule</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeImperfection">writeImperfection</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writePerfection">writePerfection</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeSimpleImperfection">writeSimpleImperfection</a></li><li data-type='method' style='display: none;'><a href="durIO.html#~breveDifference">breveDifference</a></li><li data-type='method' style='display: none;'><a href="durIO.html#~gcd">gcd</a></li></ul></li><li><a href="imperfect.html">imperfect</a><ul class='methods'><li data-type='method' style='display: none;'><a href="imperfect.html#.firstBeatImperfection">firstBeatImperfection</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#.midBeatImperfection">midBeatImperfection</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#.secondBeatImperfection">secondBeatImperfection</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#.thirdBeatImperfection">thirdBeatImperfection</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~canImperfect">canImperfect</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~divisionLikeRests">divisionLikeRests</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~firstBeatImperfectionCheck">firstBeatImperfectionCheck</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~imperfectingLevels">imperfectingLevels</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~indexOfNextDot">indexOfNextDot</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~indexOfNextSameOrLongerOrDot">indexOfNextSameOrLongerOrDot</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~solidBlock">solidBlock</a></li></ul></li><li><a href="ioHandler.html">ioHandler</a></li><li></li><li><a href="post.html">post</a><ul class='methods'><li data-type='method' style='display: none;'><a href="post.html#.run">run</a></li><li data-type='method' style='display: none;'><a href="post.html#~addAppInfo">addAppInfo</a></li><li data-type='method' style='display: none;'><a href="post.html#~addBarLines">addBarLines</a></li></ul></li><li><a href="rm.html">rm</a><ul class='methods'><li data-type='method' style='display: none;'><a href="rm.html#.augDot">augDot</a></li><li data-type='method' style='display: none;'><a href="rm.html#.beatUnitStructure">beatUnitStructure</a></li><li data-type='method' style='display: none;'><a href="rm.html#.divisionDot">divisionDot</a></li><li data-type='method' style='display: none;'><a href="rm.html#.dupleMinimCountFromElement">dupleMinimCountFromElement</a></li><li data-type='method' style='display: none;'><a href="rm.html#.firstPerfectLevel">firstPerfectLevel</a></li><li data-type='method' style='display: none;'><a href="rm.html#.isAlterable">isAlterable</a></li><li data-type='method' style='display: none;'><a href="rm.html#.isColored">isColored</a></li><li data-type='method' style='display: none;'><a href="rm.html#.isNote">isNote</a></li><li data-type='method' style='display: none;'><a href="rm.html#.leveleq">leveleq</a></li><li data-type='method' style='display: none;'><a href="rm.html#.mensurSummary">mensurSummary</a></li><li data-type='method' style='display: none;'><a href="rm.html#.minimStructures">minimStructures</a></li><li data-type='method' style='display: none;'><a href="rm.html#.noteInt">noteInt</a></li><li data-type='method' style='display: none;'><a href="rm.html#.noteOrRest">noteOrRest</a></li><li data-type='method' style='display: none;'><a href="rm.html#.notePerfectAsWhole">notePerfectAsWhole</a></li><li data-type='method' style='display: none;'><a href="rm.html#.regularlyPerfect">regularlyPerfect</a></li><li data-type='method' style='display: none;'><a href="rm.html#.simpleMinims">simpleMinims</a></li><li data-type='method' style='display: none;'><a href="rm.html#~noteIntFromDur">noteIntFromDur</a></li></ul></li><li><a href="startTimes.html">startTimes</a><ul class='methods'><li data-type='method' style='display: none;'><a href="startTimes.html#.addAllStartTimes">addAllStartTimes</a></li><li data-type='method' style='display: none;'><a href="startTimes.html#.addBreveBoundariesForBlock">addBreveBoundariesForBlock</a></li><li data-type='method' style='display: none;'><a href="startTimes.html#.addStartTimes">addStartTimes</a></li><li data-type='method' style='display: none;'><a href="startTimes.html#.addStartTimesForBlock">addStartTimesForBlock</a></li><li data-type='method' style='display: none;'><a href="startTimes.html#.updateBlocks">updateBlocks</a></li></ul></li><li><a href="vrvInterface.html">vrvInterface</a><ul class='methods'><li data-type='method' style='display: none;'><a href="vrvInterface.html#.applyZoom">applyZoom</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#.loadData">loadData</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#.nextPage">nextPage</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#.prevPage">prevPage</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#.zoomIn">zoomIn</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#.zoomOut">zoomOut</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#~bindInteractionEvents">bindInteractionEvents</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#~deselectEvent">deselectEvent</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#~loadPage">loadPage</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#~selectEvent">selectEvent</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#~setOptions">setOptions</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#baseUrl">baseUrl</a></li><li><a href="global.html#basicAnalysisDone">basicAnalysisDone</a></li><li><a href="global.html#checkIfAlreadyRun">checkIfAlreadyRun</a></li><li><a href="global.html#complexAnalysisDone">complexAnalysisDone</a></li><li><a href="global.html#currentParams">currentParams</a></li><li><a href="global.html#currentUrl">currentUrl</a></li><li><a href="global.html#evaluateResults">evaluateResults</a></li><li><a href="global.html#fetchMEI">fetchMEI</a></li><li><a href="global.html#getProperty">getProperty</a></li><li><a href="global.html#getPropertyByID">getPropertyByID</a></li><li><a href="global.html#getSectionBlocks">getSectionBlocks</a></li><li><a href="global.html#hideDetails">hideDetails</a></li><li><a href="global.html#highlightQualities">highlightQualities</a></li><li><a href="global.html#instructor">instructor</a></li><li><a href="global.html#interpreter">interpreter</a></li><li><a href="global.html#intResp">intResp</a></li><li><a href="global.html#isRest">isRest</a></li><li><a href="global.html#loadData">loadData</a></li><li><a href="global.html#makeXmlCode">makeXmlCode</a></li><li><a href="global.html#meiFile">meiFile</a></li><li><a href="global.html#nextEvent">nextEvent</a></li><li><a href="global.html#prevEvent">prevEvent</a></li><li><a href="global.html#selectAdjacentElByID">selectAdjacentElByID</a></li><li><a href="global.html#setProperty">setProperty</a></li><li><a href="global.html#setPropertyByID">setPropertyByID</a></li><li><a href="global.html#showDetails">showDetails</a></li><li><a href="global.html#shownEvent">shownEvent</a></li><li><a href="global.html#submitFeedback">submitFeedback</a></li><li><a href="global.html#updateBlob">updateBlob</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">ioHandler.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

/** 
 * @fileoverview 
 * The ioHandler is the connecting layer between the meiFile and the interpreter or the user interface.
 * The interpreter writes and reads it's output through ioHandler.
 * The user interface retrieves data from the meiFile through ioHandler and writes user input to the meiFile.
 */

/** 
 * @namespace ioHandler
 * @desc The ioHandler is the connecting layer between the meiFile and the interpreter or the user interface.
 */

var ioHandler = (function() {
    // private

    /**
     * determine data storage in MEIdoc
     */
    const attributes = ["num", "numbase", "dur.quality", "dur.metrical", 
                        "dur", "tempus", "prolatio", "modusminor", "modusmaior", "form", "colored"];

    /**
     * Writes attributes from a dictonary object to the element.
     * Dictionary keys contain attribute names.
     * @param {Element} element 
     * @param {Object&lt;string,string>} propObject 
     */
    function setAttr(element, propObject) {
        for(let attr in propObject)
        {
            if(propObject[attr]==="none" || propObject[attr]===null)
            {
                element.removeAttributeNS(null, attr);
            }
            else
            {
                element.setAttributeNS(null, attr, propObject[attr]);
            }
        }
    }

    /**
     * Retrieves the value of a specified attribute or a dictionary of attribute values.
     * @param {Element} element 
     * @param {Object&lt;string,string>} propObject 
     * @returns {string|Object&lt;string,string>} attribute value(s)
     */
    function getAttr(element, propName) {
        var attr;
        
        if(propName)
        {
            attr = element.getAttributeNS(null, propName);
        }
        else
        {
            attr = {};

            for (let attribute of element.attributes)
            {
                attr[attribute.nodeName] = attribute.value;
            }
        }

        return attr;
    }

    /**
     * Retrieves either a dictionary of annotation values for an element or the value of one property.
     * @param {string} elementID xml:id of element
     * @param {string} propName name of property
     * @returns {string|Object&lt;string,string>} annotation value(s)
     */
    function getAnnot(elementID, propName) {
        var annotations = meiFile.getAnnotation(elementID);

        var annots = null;

        // there are no annotations before the interpreter has run!
        if(annotations)
        {
            annots = {};
            for (let annot of annotations.children)
            {
                let annotType = annot.getAttribute("type");
                let annotValue = getCorrValue(annot);
                let interpreterValue = getAnnotValueByResp(annot, true);
                let userValue = getAnnotValueByResp(annot, false);
                let annotSic = getSicValue(annot);

                // two of those values should always be identical; this isn't beautiful
                // but we need to distinguish old/new values and by resp
                // sic is either the old value or null
                // corr is the currently "valid" value
                annots[annotType] = 
                    {sic: annotSic, 
                    corr: annotValue, 
                    interpreter : interpreterValue, 
                    user : userValue};
                
            }
        }

        // if a propName is given, we retrieve only the defined property
        if(propName)
        {
            annots = annots[propName];
        }

        return annots;
    }

    /**
     * Modifies or add annotations for the defined element
     * @param {string} elementID xml:id of element
     * @param {Object&lt;string,string>} propObject 
     * @param {string} resp URI to responsible agent in header, default is interpreter
     */
    function setAnnot(elementID, propObject, resp = intResp) {
        var annot;

        // pulling the gobal document like a bunny out of the hat is bad, 
        // but just live with it in this one case...
        if(meiFile.annotations[elementID])
        {
            annot = meiFile.getAnnotation(elementID);
        }
        else 
        {
            annot = meiFile.addAnnotation(elementID);
        }

        for (let attr in propObject)
        {
            let attrAnnot = getAnnotElement(elementID, attr);
            if(attrAnnot==null)
            {
                attrAnnot = meiFile.addMeiElement("annot");
                attrAnnot.setAttribute("type", attr);
                attrAnnot.setAttribute("resp", resp);
                annot.appendChild(attrAnnot);
            }

            /** 
             * Choose whether value is just added, or correction should be added:
             * * If there is no value, just add value
             * * In interpreter mode: After interpreter has finished, add corr (we can assume resp is different)
             * * In instructor mode: If value and resp is not identical, add corr
             * (addCorr() checks for identical values)
             */
            // remove annot if value is null (unlike attributes)
            if(propObject[attr]===null)
            {
                attrAnnot.remove();
            }
            else if (
                attrAnnot.textContent==="" ||
                (instructor===false &amp;&amp; complexAnalysisDone===false) ||
                (instructor===true &amp;&amp; attrAnnot.getAttribute("resp")===resp)
                )
            {
                attrAnnot.textContent = propObject[attr];
            }
            
            else
            {
                addCorr(elementID, attr, propObject[attr], resp);
            }
        }
    }

    /**
     * Returns the annot element for a described element and a given property name.
     * @param {string} elementID 
     * @param {string} propName 
     * @returns {Element} annot element
     */
    function getAnnotElement(elementID, propName) {
        var attrEl = null;

        if(meiFile.getAnnotation(elementID))
        {
            let annot = meiFile.annotations[elementID];
            attrEl = meiFile.doXPathOnDoc("./mei:annot[@type='" + propName + "']", annot, 9).singleNodeValue;
        }

        return attrEl;
    }

    /**
     * Adds a choice with sic/corr to an inner anotation
     * @param {string} elementID 
     * @param {string} propName 
     * @returns {Element} annot element with choice
     */
    function addApp(elementID, propName)
    {
        var attrEl = getAnnotElement(elementID, propName);
        if(attrEl)
        {
            if(attrEl.getElementsByTagName("choice").length===0)
            {
                let oldValueNowSic = attrEl.textContent;
                attrEl.textContent = '';
                let choice = meiFile.addMeiElement("choice");
                attrEl.appendChild(choice);

                let sic = meiFile.addMeiElement("sic");
                choice.appendChild(sic);
                sic.textContent = oldValueNowSic;

                let corr = meiFile.addMeiElement("corr");
                choice.appendChild(corr);
            }

            return attrEl;
        }
        else
        {
            return null;
        }
    }

    // don't implement this now: a value once set wil be set for eternity
    // function setSic(elementID, propName, sicValue) {}
    
    /**
     * Add a correction of an annotation if the value differs
     * @param {string} elementID xml:id of element
     * @param {string} propName property name
     * @param {string} corrValue new correct value
     * @param {string} resp responsible agent for the new value
     */
    function addCorr(elementID, propName, corrValue, resp) 
    {    
        var oldValue = getAnnot(elementID, propName);
        
        // add apparatus only if values differ
        // corr is standard if there is no sic yet
        if (oldValue.sic === null &amp;&amp; corrValue.toString()!=oldValue.corr)
        {
            let attrEl = addApp(elementID, propName);
            // updating user values should not create an apparatus
            if(oldValue.corr !== oldValue.user)
            {
                
                if(attrEl!==null)
                {
                    let oldResp = attrEl.getAttribute("resp");
                    let corrEl = meiFile.doXPathOnDoc("descendant::mei:corr", attrEl, 9).singleNodeValue;
                    corrEl.textContent = corrValue;
                    if(resp &amp;&amp; resp !== oldResp)
                    {
                        corrEl.setAttribute("resp", resp);
                        let sicEl = meiFile.doXPathOnDoc("descendant::mei:sic", attrEl, 9).singleNodeValue;
                        sicEl.setAttribute("resp", oldResp);
                        attrEl.removeAttribute("resp");
                    }
                }
            }
            else
            {
                attrEl.textContent = corrValue;
                attrEl.setAttribute("resp",resp);
            }
            
        }
        // if there is a sic and corr values differ, update corr value if resp is identical
        // if resp is not identical, what should be done then??? 
        // --> last value of identical resp needs to be overwritten
        // to avoid any further complexity, only one sic and one corr is possible
        // and one of them should always reflect the interpreter
        else if(oldValue.sic != null &amp;&amp; corrValue.toString()!=oldValue.corr)
        {
            let attrEl = addApp(elementID, propName);
            if(attrEl!==null)
            {
                let corrEl = meiFile.doXPathOnDoc("descendant::mei:corr", attrEl, 9).singleNodeValue;
                let sicEl = meiFile.doXPathOnDoc("descendant::mei:sic", attrEl, 9).singleNodeValue;
                
                let attrResp = attrEl.getAttribute("resp");
                let corrResp = corrEl.getAttribute("resp");
                let sicResp = sicEl.getAttribute("resp");

                if(resp)
                {
                    if(resp === attrResp)
                    {
                        //remove app if resp
                        attrEl.removeChild(attrEl.getElementsByTagName("choice")[0]);
                        attrEl.textContent = corrValue;
                    }
                    else if(resp === corrResp)
                    {
                        // if corrResp is identical with current resp, replace value
                        corrEl.textContent = corrValue;
                    }
                    else
                    {
                        // check if corr is from user and update corr including resp?
                        if(corrResp &amp;&amp; resp &amp;&amp; oldValue.corr === oldValue.user)
                        {
                            corrEl.textContent = corrValue;
                            corrEl.setAttribute("resp",resp);
                        }

                        // else, do nothing?
                    }
                }
            }
        }
        else
        {
            // if resp is not already included, add it
            let attrEl = getAnnotElement(elementID, propName);
            let oldResp = attrEl.getAttribute("resp");
            
            if(resp &amp;&amp; oldResp &amp;&amp; !oldResp.includes(resp))
            {
                attrEl.setAttribute("resp", oldResp + " " + resp);
            }
        }
    }

    /**
     * Retrieves the (correct) valid value of an annot.
     * @param {Element} propAnnot 
     * @returns {string}
     */
    function getCorrValue(propAnnot)
    {
        var corrValue;
        let corrEl = meiFile.doXPathOnDoc("descendant::mei:corr", propAnnot, 9).singleNodeValue;

        if(corrEl)
        {
            corrValue = corrEl.textContent;
        }
        else
        {
            corrValue = propAnnot.textContent;
        }

        return corrValue;
    }

    /**
     * Retrieves the (wrong) non-valid value of an annot.
     * @param {Element} propAnnot 
     * @returns {string}
     */
    function getSicValue(propAnnot)
    {
        var sicValue = null;
        let sicEl = meiFile.doXPathOnDoc("descendant::mei:sic", propAnnot, 9).singleNodeValue;

        if(sicEl)
        {
            sicValue = sicEl.textContent;
        }

        return sicValue;
    }

    /**
     * Retrieves a value by responsibility (either interpreter or user)
     * Resp can contain tokens of anyURI, so check whether intResp is contained or not contained at all...
     * @param {Element} propAnnot 
     * @param {boolean} returnInterpreter Which resp to return: true = interpreter; false = user
     * @returns {string} annotation value
     */
    function getAnnotValueByResp(propAnnot, returnInterpreter = true)
    {
        var annotValue = null;

        if(returnInterpreter)
        {
            annotValue = meiFile.doXPathOnDoc("./descendant-or-self::*[contains(@resp,'" + intResp + "')]/text()", propAnnot, 2).stringValue;
        }
        else
        {
            annotValue = meiFile.doXPathOnDoc("./descendant-or-self::*[@resp!='" + intResp + "']/text()", propAnnot, 2).stringValue;
        }

        return annotValue;
    }

    /*function getSic(elementID, propName) 
    {
        return meiFile.doXPathOnDoc("descendant::mei:sic", propAnnot, 9).singleNodeValue;
    }

    function getCorr(elementID, propName)
    {
        return meiFile.doXPathOnDoc("descendant::mei:corr", propAnnot, 9).singleNodeValue
    }*/

    /**
     * Adds a &lt;respStmt> to the title statement of the file description.
     * Will only be added for names that aren't contained in a &lt;respStmt> yet.
     * @param {string} respTxt role of responsibility
     * @param {*} name name of responsible agent
     * @param {*} initials initials of respinsible agent
     */
    function addRespStmt(respTxt, name, initials)
    {
        var titleStmt = meiFile.doXPathOnDoc("//mei:fileDesc/mei:titleStmt", meiFile.doc, 9).singleNodeValue;
        var respRes = meiFile.doXPathOnDoc("./mei:respStmt[./mei:resp='"+respTxt+"']", titleStmt, 5);
        var respStmt = respRes.iterateNext();

        var respPersNames = [];

        while (respStmt)
        {
            let persName = respStmt.getElementsByTagName("persName")[0];
            respPersNames.push(persName.textContent);

            respStmt = respRes.iterateNext();
        }

        if(respStmt == null &amp;&amp; respPersNames.indexOf(name)===-1) 
        {
            respStmt = meiFile.addMeiElement("respStmt");
            titleStmt.append(respStmt);
            let resp = meiFile.addMeiElement("resp");
            resp.textContent = respTxt;
            respStmt.append(resp);
            let persName = meiFile.addMeiElement("persName", initials);
            persName.textContent = name;
            respStmt.append(persName);
        }
    }

    return {
        //public

        /**
         * Read properties from attrs and annots to handle non note-rest objects.
         * Since annots get merged into attrs, annots overwrite attr values,
         * this is intended!
         * @param {Element} element 
         * @param {string} propName 
         * @param {Integer} resp Toggles return values by resp: 0 = all values; 1 = interpreter; 2 = user, 3 = corr
         * @returns {string|Object}
         */
        getProperty : function (element, propName, resp = 1) {
            // 
            
            var property = {};

            let attrs = getAttr(element);
            let annots = getAnnot(element.getAttribute("xml:id"));

            // gather only interpreter values
            if(resp===1)
            {
                for (let attr in annots)
                {
                    if(typeof annots[attr] !== "string")
                    {
                        annots[attr] = annots[attr].interpreter;
                    }
                }
            }
            // gather user values
            else if(resp===2)
            {
                for (let attr in annots)
                {
                    if(typeof annots[attr] !== "string")
                    {
                        annots[attr] = annots[attr].user;
                    }
                }
            }
            // gather corr values
            else if(resp===3)
            {
                for (let attr in annots)
                {
                    if(typeof annots[attr] !== "string")
                    {
                        annots[attr] = annots[attr].corr;
                    }
                }
            }

            property = {...attrs, ...annots};

            if(propName)
            {
                property = property[propName];
            }
                        
            return property;
        },

        /**
         * Read properties from attrs and annots to handle non note-rest objects.
         * Since annots get merged into attrs, annots overwrite attr values,
         * this is intended!
         * @param {string} elementID 
         * @param {string} propName 
         * @param {Integer} resp Toggles return values by resp: 0 = all values; 1 = interpreter; 2 = user, 3 = corr
         * @returns {string|Object}
         */
        getPropertyByID : function (elementID, propName, resp = 1) {
            let element = meiFile.eventDict[elementID];

            return this.getProperty(element, propName, resp);
        },

        /**
         * Writes properties to attributes and annotations for the given element.
         * @param {Element} element 
         * @param {Object} propObject 
         * @param {string} resp URI to responsible agent in header, default is interpreter
         */
        setProperty : function (element, propObject, resp = intResp) {
            var annots = {};
            var attrs = {};

            for(const [key, value] of Object.entries(propObject))
            {
                // attributes need to be set redundantly because 
                // it's not possible to track corrections within attributes
                if(attributes.find(item => item === key))
                {
                    attrs[key] = value;
                }
                //else
                //{
                    annots[key] = value;
                //}
            }
            if(element)
            {
                if(Object.entries(attrs)) setAttr(element, attrs);
                if(Object.entries(annots)) setAnnot(element.getAttribute("xml:id"), annots, resp);
            }
        },

        /**
         * Writes properties to attributes and annotations for the given element.
         * Takes xml:id of affected element.
         * @param {string} elementID 
         * @param {Object} propObject 
         * @param {string} resp URI to responsible agent in header, default is interpreter
         */
        setPropertyByID : function (elementID, propObject, resp = intResp) {
            let element = meiFile.eventDict[elementID];

            this.setProperty(element, propObject, resp);
        },

        /**
         * Writes the user input about a certain element.
         * Addresses the affected element by xml:id.
         * @param {Object} feedbackObj 
         * @param {string} elementID 
         */
        submitFeedback(feedbackObj, elementID) {
            //get user credentials out of feedbackObj
            var userName = feedbackObj["resp.name"];
            var userIni = "#" + feedbackObj["resp.initials"];
            delete feedbackObj["resp.name"];
            delete feedbackObj["resp.initials"];

            var text = "Evaluated interpreter results.";
            var resp = "evaluated by";

            if(instructor===true)
            {
                text = "Resolved durations in mensural instuctor mode";
                resp = "resolved by";
            }

            // create respStmt in Header if not done already
            addRespStmt(resp, userName, userIni);
            meiFile.addRevision(userIni, text);
            
            // check which values differ
            // update values into sic/corr
            var currentValues = getAnnot(elementID);

            for(const [key, value] of Object.entries(feedbackObj))
            {
                if(value==null || 
                    (currentValues &amp;&amp;
                        (currentValues[key] &amp;&amp; value===currentValues[key]))
                )
                {
                    delete feedbackObj[key];
                }
            }

            this.setPropertyByID(elementID, feedbackObj, userIni);
        },

        /**
         * Writes a comment during interpretation to an element
         * @param {DOMElement} el 
         * @param {String} comment 
         * @param {String} resp responsible agent (default: interpreter)
         * @param {String} respName Name of responsible agent
         * @memberof durIO
         */
        writeComment : function (el, comment, resp = intResp, respName) {
            if(resp !== intResp)
            {
                addRespStmt("commented by",respName,resp);
                meiFile.addRevision("#"+resp, "Commented resolutions.");
            }
            this.setProperty(el, {'comment': comment}, "#"+resp);
        },

        /**
         * Writes a comment during interpretation to an element
         * @param {String} elementID element id 
         * @param {String} comment 
         * @param {String} resp responsible agent (default: interpreter)
         * @memberof durIO
         */
        writeCommentById : function (elementID, comment, resp = intResp, respName) {
            let element = meiFile.eventDict[elementID];
            this.writeComment(element, comment, resp, respName);
        }

    }
})();</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.10</a> on Wed Mar 23 2022 13:32:01 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
