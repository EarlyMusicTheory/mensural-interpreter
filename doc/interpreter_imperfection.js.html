<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>interpreter/imperfection.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="MEIdoc.html">MEIdoc</a><ul class='methods'><li data-type='method' style='display: none;'><a href="MEIdoc.html#addAnnotation">addAnnotation</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#addMeiElement">addMeiElement</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#addRevision">addRevision</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#appendToIdDictionary">appendToIdDictionary</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#doXPathOnDoc">doXPathOnDoc</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#getAnnotation">getAnnotation</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#getBlockByEventId">getBlockByEventId</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#getBlocksFromSections">getBlocksFromSections</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#initAnnotations">initAnnotations</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#initEventDict">initEventDict</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#preprocess">preprocess</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#proportionMultiplier">proportionMultiplier</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#renewBlob">renewBlob</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="alterate.html">alterate</a><ul class='methods'><li data-type='method' style='display: none;'><a href="alterate.html#.firstBeatAlteration">firstBeatAlteration</a></li><li data-type='method' style='display: none;'><a href="alterate.html#.midBeatAlteration">midBeatAlteration</a></li><li data-type='method' style='display: none;'><a href="alterate.html#.secondBeatAlteration">secondBeatAlteration</a></li><li data-type='method' style='display: none;'><a href="alterate.html#.thirdBeatAlteration">thirdBeatAlteration</a></li><li data-type='method' style='display: none;'><a href="alterate.html#~checkForGeneralAlteration">checkForGeneralAlteration</a></li></ul></li><li><a href="basic.html">basic</a><ul class='methods'><li data-type='method' style='display: none;'><a href="basic.html#.beatIndependentDurations">beatIndependentDurations</a></li><li data-type='method' style='display: none;'><a href="basic.html#~actOnColoration">actOnColoration</a></li><li data-type='method' style='display: none;'><a href="basic.html#~actOnDots">actOnDots</a></li><li data-type='method' style='display: none;'><a href="basic.html#~allUnalterableImperfectLevels">allUnalterableImperfectLevels</a></li><li data-type='method' style='display: none;'><a href="basic.html#~anteSim">anteSim</a></li><li data-type='method' style='display: none;'><a href="basic.html#~labelRests">labelRests</a></li><li data-type='method' style='display: none;'><a href="basic.html#~simplestAlterations">simplestAlterations</a></li></ul></li><li><a href="complexBeats.html">complexBeats</a><ul class='methods'><li data-type='method' style='display: none;'><a href="complexBeats.html#.complexAnalysis">complexAnalysis</a></li><li data-type='method' style='display: none;'><a href="complexBeats.html#~afterTheEasyBits">afterTheEasyBits</a></li></ul></li><li><a href="durIO.html">durIO</a><ul class='methods'><li data-type='method' style='display: none;'><a href="durIO.html#.readBlockFrom">readBlockFrom</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.readDur">readDur</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.readDurGes">readDurGes</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.readStartsAt">readStartsAt</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.setBeatPos">setBeatPos</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.setBreveBoundaries">setBreveBoundaries</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.setDurGesPerBlock">setDurGesPerBlock</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.setStartsAt">setStartsAt</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.windowDuration">windowDuration</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeAlteration">writeAlteration</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeComment">writeComment</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeCommentById">writeCommentById</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeDur">writeDur</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeDurGes">writeDurGes</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeDurWithRule">writeDurWithRule</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeImperfection">writeImperfection</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writePerfection">writePerfection</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeSimpleImperfection">writeSimpleImperfection</a></li><li data-type='method' style='display: none;'><a href="durIO.html#~breveDifference">breveDifference</a></li><li data-type='method' style='display: none;'><a href="durIO.html#~gcd">gcd</a></li></ul></li><li><a href="imperfect.html">imperfect</a><ul class='methods'><li data-type='method' style='display: none;'><a href="imperfect.html#.firstBeatImperfection">firstBeatImperfection</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#.midBeatImperfection">midBeatImperfection</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#.secondBeatImperfection">secondBeatImperfection</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#.thirdBeatImperfection">thirdBeatImperfection</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~canImperfect">canImperfect</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~divisionLikeRests">divisionLikeRests</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~firstBeatImperfectionCheck">firstBeatImperfectionCheck</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~imperfectingLevels">imperfectingLevels</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~indexOfNextDot">indexOfNextDot</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~indexOfNextSameOrLongerOrDot">indexOfNextSameOrLongerOrDot</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~solidBlock">solidBlock</a></li></ul></li><li><a href="ioHandler.html">ioHandler</a></li><li></li><li><a href="post.html">post</a><ul class='methods'><li data-type='method' style='display: none;'><a href="post.html#.run">run</a></li><li data-type='method' style='display: none;'><a href="post.html#~addAppInfo">addAppInfo</a></li><li data-type='method' style='display: none;'><a href="post.html#~addBarLines">addBarLines</a></li></ul></li><li><a href="rm.html">rm</a><ul class='methods'><li data-type='method' style='display: none;'><a href="rm.html#.augDot">augDot</a></li><li data-type='method' style='display: none;'><a href="rm.html#.beatUnitStructure">beatUnitStructure</a></li><li data-type='method' style='display: none;'><a href="rm.html#.divisionDot">divisionDot</a></li><li data-type='method' style='display: none;'><a href="rm.html#.dupleMinimCountFromElement">dupleMinimCountFromElement</a></li><li data-type='method' style='display: none;'><a href="rm.html#.firstPerfectLevel">firstPerfectLevel</a></li><li data-type='method' style='display: none;'><a href="rm.html#.isAlterable">isAlterable</a></li><li data-type='method' style='display: none;'><a href="rm.html#.isColored">isColored</a></li><li data-type='method' style='display: none;'><a href="rm.html#.isNote">isNote</a></li><li data-type='method' style='display: none;'><a href="rm.html#.leveleq">leveleq</a></li><li data-type='method' style='display: none;'><a href="rm.html#.mensurSummary">mensurSummary</a></li><li data-type='method' style='display: none;'><a href="rm.html#.minimStructures">minimStructures</a></li><li data-type='method' style='display: none;'><a href="rm.html#.noteInt">noteInt</a></li><li data-type='method' style='display: none;'><a href="rm.html#.noteOrRest">noteOrRest</a></li><li data-type='method' style='display: none;'><a href="rm.html#.notePerfectAsWhole">notePerfectAsWhole</a></li><li data-type='method' style='display: none;'><a href="rm.html#.regularlyPerfect">regularlyPerfect</a></li><li data-type='method' style='display: none;'><a href="rm.html#.simpleMinims">simpleMinims</a></li><li data-type='method' style='display: none;'><a href="rm.html#~noteIntFromDur">noteIntFromDur</a></li></ul></li><li><a href="startTimes.html">startTimes</a><ul class='methods'><li data-type='method' style='display: none;'><a href="startTimes.html#.addAllStartTimes">addAllStartTimes</a></li><li data-type='method' style='display: none;'><a href="startTimes.html#.addBreveBoundariesForBlock">addBreveBoundariesForBlock</a></li><li data-type='method' style='display: none;'><a href="startTimes.html#.addStartTimes">addStartTimes</a></li><li data-type='method' style='display: none;'><a href="startTimes.html#.addStartTimesForBlock">addStartTimesForBlock</a></li><li data-type='method' style='display: none;'><a href="startTimes.html#.updateBlocks">updateBlocks</a></li></ul></li><li><a href="vrvInterface.html">vrvInterface</a><ul class='methods'><li data-type='method' style='display: none;'><a href="vrvInterface.html#.applyZoom">applyZoom</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#.loadData">loadData</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#.nextPage">nextPage</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#.prevPage">prevPage</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#.zoomIn">zoomIn</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#.zoomOut">zoomOut</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#~bindInteractionEvents">bindInteractionEvents</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#~deselectEvent">deselectEvent</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#~loadPage">loadPage</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#~selectEvent">selectEvent</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#~setOptions">setOptions</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#baseUrl">baseUrl</a></li><li><a href="global.html#basicAnalysisDone">basicAnalysisDone</a></li><li><a href="global.html#checkIfAlreadyRun">checkIfAlreadyRun</a></li><li><a href="global.html#complexAnalysisDone">complexAnalysisDone</a></li><li><a href="global.html#currentParams">currentParams</a></li><li><a href="global.html#currentUrl">currentUrl</a></li><li><a href="global.html#evaluateResults">evaluateResults</a></li><li><a href="global.html#fetchMEI">fetchMEI</a></li><li><a href="global.html#getProperty">getProperty</a></li><li><a href="global.html#getPropertyByID">getPropertyByID</a></li><li><a href="global.html#getSectionBlocks">getSectionBlocks</a></li><li><a href="global.html#hideDetails">hideDetails</a></li><li><a href="global.html#highlightQualities">highlightQualities</a></li><li><a href="global.html#instructor">instructor</a></li><li><a href="global.html#interpreter">interpreter</a></li><li><a href="global.html#intResp">intResp</a></li><li><a href="global.html#isRest">isRest</a></li><li><a href="global.html#loadData">loadData</a></li><li><a href="global.html#makeXmlCode">makeXmlCode</a></li><li><a href="global.html#meiFile">meiFile</a></li><li><a href="global.html#nextEvent">nextEvent</a></li><li><a href="global.html#prevEvent">prevEvent</a></li><li><a href="global.html#selectAdjacentElByID">selectAdjacentElByID</a></li><li><a href="global.html#setProperty">setProperty</a></li><li><a href="global.html#setPropertyByID">setPropertyByID</a></li><li><a href="global.html#showDetails">showDetails</a></li><li><a href="global.html#shownEvent">shownEvent</a></li><li><a href="global.html#submitFeedback">submitFeedback</a></li><li><a href="global.html#updateBlob">updateBlob</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">interpreter/imperfection.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** @fileoverview Check imperfection rules */
"use strict";

/**
 * @namespace imperfect
 * @desc Check imperfection rules
 */
var imperfect = (function() {
    /** private */

    /**
     * Having sifted the trivial cases out, attempts to resolve cases that
     * rely on context, particularly the shorter notes that follow this one.
     * @param {DOMObject} event mei:note (rest would have been resolved already)
     * @param {Array} window List of following events (until the next
     * division dot or equivalent, or the next event of similar or greater
     * length).
     * @param {DOMObject} mens mei:mensur
     * @returns {DOMObject} This function returns the modified event (why?)
     * @memberof imperfect
     * @inner
     */
    function firstBeatImperfectionCheck(event, window, mens){
        var level = rm.noteInt(event);
        var duration = durIO.windowDuration(window, mens);
    //	if(level==5) console.log(event, duration);
        var imperfectionPossibilities = imperfectingLevels(event, mens);
    //	console.log(imperfectionPossibilities);
        if(duration.definite){
            while(imperfectionPossibilities.length){
                var nextToTry = imperfectionPossibilities.pop();
                var imperfectingUnits = duration.definite / nextToTry;
                if(imperfectingUnits===1){
                    durIO.writeImperfection(event, nextToTry, mens, 'I.4a');
                    return true;
                } else if (imperfectingUnits===2){
                    if(rm.isAlterable(window[window.length-1], mens)){
                        durIO.writePerfection(event, mens, 'I.5');
                        //event.setAttributeNS(null, 'rule', 'I.5');
                        //event.setAttributeNS(null, 'quality', 'p');
                        //event.setAttributeNS(null, 'dur.ges', simpleMinims(event, mens)+'b');
                        //durIO.writeDur(rm.simpleMinims(event, mens), event, false);
                        ioHandler.writeComment(event, 'trusting in alteration');
                    } else {
                        durIO.writeImperfection(event, nextToTry, mens, 'I.5-add');
                        ioHandler.writeComment(event, 'Alteration is impossible');
                    }
                    ///WTF!!!!!?!
                    return false;
                } else if (imperfectingUnits===3 || imperfectingUnits===6 || imperfectingUnits===9){
                    durIO.writePerfection(event, mens, 'I.6');
                    //event.setAttributeNS(null, 'rule', 'I.6');
                    //event.setAttributeNS(null, 'quality', 'p');
                    //event.setAttributeNS(null, 'dur.ges', simpleMinims(event, mens)+'b');
                    //durIO.writeDur(rm.simpleMinims(event, mens), event, false);
                    return false;
                } else if (imperfectingUnits>3){
                    durIO.writeImperfection(event, nextToTry, mens, 'I.4b');
                    return true;
                }
            }
        } else if (solidBlock(duration.approximation, imperfectionPossibilities)){
            // Obvious blocks of perfect units aren't going to be altered
            durIO.writePerfection(event, mens, 'I.5-literalunits', true);
            //event.setAttributeNS(null, 'rule', 'I.5-literalunits');
            //event.setAttributeNS(null, 'quality', 'p');
            //event.setAttributeNS(null, 'defaultminims', rm.simpleMinims(event, mens));
            //durIO.writeDur(rm.simpleMinims(event, mens), event);
            return true;
        } else if(duration.approximation/rm.simpleMinims(event, mens, -1) === 2 &amp;&amp; rm.mensurSummary(mens)[level-4]===3
                            &amp;&amp; rm.noteInt(window[window.length-1])===level-1 &amp;&amp; rm.isAlterable(window[window.length-1], mens)){
            // This is a window with the equivalent of two units, one of which is alterable
            // The last note of the window will be altered
            durIO.writePerfection(event, mens, 'I.6-literalunits', true);
            //event.setAttributeNS(null, 'rule', 'I.6-literalunits');
            //event.setAttributeNS(null, 'quality', 'p');
            //event.setAttributeNS(null, 'defaultminims', rm.simpleMinims(event, mens));
            //durIO.writeDur(rm.simpleMinims(event, mens), event);
            ioHandler.writeComment(event, 'trusting in alteration');		
        } else if(duration.bareMinimum > 3 * imperfectionPossibilities[imperfectionPossibilities.length-1]){
            var imperfector = imperfectionPossibilities[imperfectionPossibilities.length-1];
            durIO.writeImperfection(event, imperfector, mens, 'I.4bi', true);
            //event.setAttributeNS(null, 'defaultminims', rm.simpleMinims(event, mens));
            //event.setAttributeNS(null, 'imperfectedBy', imperfector);
            return true;		
        } else if(duration.approximateMinimum > 3 * imperfectionPossibilities[imperfectionPossibilities.length-1]){
            var imperfector = imperfectionPossibilities[imperfectionPossibilities.length-1];
            durIO.writeImperfection(event, imperfector, mens, 'I.4bii', false);
            //event.setAttributeNS(null, 'defaultminims', rm.simpleMinims(event, mens));
            //event.setAttributeNS(null, 'imperfectedBy', imperfector);
            return true;		
        } else {
            console.log('failed to resolve', event, mens, duration);
        }
    }

    /**
     * Forward window support – find the next note that's at least as
     * long, or find a dot of division
     * @param {integer} level Level of the note
     * @param {integer} index Index of the current event (start point for the search)
     * @param {Array} seq Array of events
     * @return {(integer|boolean)} Position if found (false if not)
     * @memberof imperfect
     * @inner
     */
    function indexOfNextSameOrLongerOrDot(level, index, seq){
        for(var i=index+1; i&lt;seq.length; i++){
            if((seq[i].tagName==='dot' &amp;&amp; seq[i].getAttributeNS(null, 'form')!=='aug')
                || (rm.noteInt(seq[i])>=level)){
                return i;
            }
        }
        return false;
    }

    /**
     * True if the level in the first argument can imperfect the level in
     * the second, given the prevailing mensuration.
     * @param {Integer} shortLevel Level (semifusa=0, fusa=1,...maxima=7) of shorter note
     * @param {Integer} longLevel Level (semifusa=0, fusa=1,...maxima=7) of longer note
     * @param {Array} menssum Summary of mensuration (as returned by {@link mensurSummary}
     * @returns {Boolean} 
     * @memberof imperfect
     * @inner
     */
    function canImperfect(shortLevel, longLevel, menssum){
        // can something at shortlevel imperfect a note at longlevel, given
        // mensum?
        
        // FIXME assumes statement in imperfectingLevels comment is correct
        // (and I'm not sure it is)
        for(var i=shortLevel-3; i&lt;longLevel-3; i++){
            if(menssum[i]===3) return true;
        }
        return false;
    }

    /**
     * Returns the minim counts for all levels that can imperfect element
     * @param {DOMObject} element
     * @param {DOMObject} mensur
     * @returns {Array} 
     * @memberof imperfect
     * @inner
     */
    function imperfectingLevels(element, mensur){
        // A note can be imperfected by any value that is less than the note's
        // highest perfect component
        var mensum = rm.mensurSummary(mensur);
        var elLevel = rm.noteInt(element) - 4;
        var perf = false;
        for(var i=elLevel; i>=0; i--){
            if(mensum[i]===3) {
                perf = i;
                break;
            }
        }
        //console.log(mensum, elLevel, perf, minimStructures(mensum));
        if(perf || perf===0){
            var possibilities = [1].concat(rm.minimStructures(mensum, perf));
            return possibilities;
        }
        return [];
    }

    /**
     * Often, rests are grouped vertically to indicate coherent mensural
     * units – in effect, the vertical displacement acting as a dot of
     * division. check whether two (implicitly adjacent) rests behave like
     * that.
     * @param {Integer} maxLevel Highest mensural level that we're
     * interested in (expressed as 0=semifusa, 1=fusa, etc.)
     * @param {DOMObject} rest1 mei:rest
     * @param {DOMObject} rest2 mei:rest
     * @param {String} direction "left" | "right"
     * @returns {Boolean} 
     * @memberof imperfect
     * @inner
     */
    function divisionLikeRests(maxLevel, rest1, rest2, direction){
        return ((!direction &amp;&amp; rm.noteInt(rest1)&lt;maxLevel &amp;&amp; rm.noteInt(rest2)&lt;maxLevel)
                        || (direction==="left" &amp;&amp; rm.noteInt(rest1)&lt;maxLevel)
                        || (direction==="right" &amp;&amp; rm.noteInt(rest2)&lt;maxLevel))
            &amp;&amp; rest1.tagName==='rest' &amp;&amp; rest2.tagName==='rest'
            &amp;&amp; rest1.getAttributeNS(null, 'loc') !== rest2.getAttributeNS(null, 'loc');
    }

    /**
     * Forward window support – find the next dot of division
     * @param {Integer} index Index of the current event (start point for the seach
     * @param {Array} seq Array of events
     * @return {Integer} Position if found (false if not)
     * @memberof imperfect
     * @inner
     */
    function indexOfNextDot(index, seq){
        for(var i=index+1; i&lt;seq.length; i++){
            if(seq[i].tagName==='dot' &amp;&amp; seq[i].getAttributeNS(null, 'form')!=='aug'){
                return i;
            }
        }
        return false;
    }

    /**
     * Returns true if a duration (in minims) is 3, 6 or 9 times the
     * length of any of a list of candidate values, otherwise returns
     * false. This is for durations of windows of notes, to see whether
     * they represent a coherent block of whole mensural units (which is
     * likely to imply that they fall on the beat and that they don't
     * imperfect their neighbours).
     * @param {Integer} minimCount
     * @param {Array} possibleDivisors
     * @returns {} 
     * @memberof imperfect
     * @inner
     */
    function solidBlock(minimCount, possibleDivisors){
        // If a block of notes looks like it is made up of a small number of
        // whole, coherent mensural units, it probably is. Given its
        // notational length, check for 3, 6, or 9 of the possible perfect
        // units.
        if(minimCount % 3 !== 0) return false;
        for(var i=possibleDivisors.length-1; i>=0; i--){
            var units = minimCount / possibleDivisors[i];
            if(units == 3 || units==6 || units==9){
                return possibleDivisors[i];
            }
        }
        return false;
    }


    return{
        /** public */

        /**
         * Given an event on the first beat, if we can tell if it's perfect,
         * label the duration. Checks simpler rules (I.3 and I.4 from the
         * rulelist). If the note remains unresolved, calls {@link
         * firstBeatAlterationCheck} with a context window of events that
         * might affect the decision.
         * @param {DOMObject} event mei:note (rest would have been resolved already)
         * @param {Integer} index The note's position in events
         * @param {Array} events Sequence of events in this section for this voice 
         * @param {DOMObject} mens mei:mensur
         * @returns {DOMObject} This function returns the modified event (why?)
         * @memberof imperfect
         */
        firstBeatImperfection : function (event, index, events, mens) {
            var level = rm.noteInt(event);
            var nextMarker = indexOfNextSameOrLongerOrDot(level, index, events);
            var rightWindow = nextMarker ? events.slice(index+1, nextMarker) : events.slice(index+1);
            var menssum = rm.mensurSummary(mens);
            if(rightWindow.length==0){
                // I.3 => perfect
                durIO.writePerfection(event, mens, 'I.3');
                //durIO.writeDur(rm.simpleMinims(event, mens), event);
                //event.setAttributeNS(null, 'quality', 'p');
                //event.setAttributeNS(null, 'rule', 'I.3-726');
                return event;
            } else if (index&lt;events.length-2
                                 &amp;&amp; (rm.divisionDot(events[index+2])
                                         || (rm.noteOrRest(events[index+2]) &amp;&amp; rm.noteInt(events[index+2])>=level))
                                 &amp;&amp; rm.noteOrRest(events[index+1]) &amp;&amp; canImperfect(rm.noteInt(events[index+1]), level, menssum)){
                // I.4 a) - a simplified case where there's an obvious
                // single note
                durIO.writeSimpleImperfection(event, mens, 'I.4a');
                return event;
            } else if (((index&lt;events.length-3 &amp;&amp; (rm.divisionDot(events[index+3]) 
                                || divisionLikeRests(rm.firstPerfectLevel(mens)+1, events[index+2], events[index+3], "left")))
                            || index==events.length-3)
                        &amp;&amp; rm.noteInt(events[index+1]) == rm.noteInt(events[index+2])
                        &amp;&amp; canImperfect(rm.noteInt(events[index+1]), level, menssum)) {
                // very special case (generalise this later)
                durIO.writeImperfection(event, 2*rm.simpleMinims(events[index+1], mens), mens, 'I.4a');
                return true;
        
            } else {
                return firstBeatImperfectionCheck(event, rightWindow, mens);
            }
        },
        
        /**
         * Given an event on the second beat, if we can tell if it's perfect,
         * label the duration. Checks rule I.8 from the rulelist
         * @param {DOMObject} event mei:note (rest would have been resolved already)
         * @param {Integer} index The note's position in events
         * @param {Array} events Sequence of events in this section for this voice 
         * @param {DOMObject} mens mei:mensur
         * @returns {DOMObject} This function returns the modified event (why?)
         * @memberof imperfect
         */
        secondBeatImperfection : function (event, index, events, mens) {
            // Let's pretend this is easy, and apply I.8 as if we *knew* that
            // something earlier can imperfect this
            durIO.writeSimpleImperfection(event, mens, 'I.8');
            return event;	
        },
        
        /**
         * Given an event on the third beat, if we can tell if it's perfect,
         * label the duration. Checks rule I.9 from the rulelist
         * @param {DOMObject} event mei:note (rest would have been resolved already)
         * @param {Integer} index The note's position in events
         * @param {Array} events Sequence of events in this section for this voice 
         * @param {DOMObject} mens mei:mensur
         * @returns {DOMObject} This function returns the modified event (why?)
         * @memberof imperfect
         */
        thirdBeatImperfection : function (event, index, events, mens) {
            // More complex
            var imperfectionPossibilities = imperfectingLevels(event, mens);
            var nextDotPos = indexOfNextDot(index, events);
            // Simplest imperfection
            if(nextDotPos &amp;&amp; nextDotPos - index &lt; 6 
                &amp;&amp; imperfectionPossibilities.indexOf(durIO.windowDuration(events.slice(index+1, nextDotPos), mens).approximation)>-1)
            {
                // There's a simple explanation, that is imperfection from behind
                durIO.writeImperfection(event, durIO.windowDuration(events.slice(index+1, nextDotPos), mens).approximation,
                                                    mens, 'I.9b');
            } 
            else 
            {
                // imperfection from ahead (by how much?)
                durIO.writeImperfection(event, imperfectionPossibilities[imperfectionPossibilities.length-1],
                                                    mens, 'I.9a');
            }
            return event;
        },
        
        /**
         * Currently a placeholder for deciding the imperfection status of a
         * note that isn't on beats 1, 2 or 3
         * @param {DOMObject} event mei:note (rest would have been resolved already)
         * @param {Integer} index The note's position in events
         * @param {Array} events Sequence of events in this section for this voice 
         * @param {DOMObject} mens mei:mensur
         * @returns {DOMObject} This function returns the altered event (why?)
         * @returns {DOMObject} Returns the event (unmodified at the moment)
         * @memberof imperfect
         */
        midBeatImperfection : function (event, index, events, mens) {
            // More complex
            return event;
        }
    }
})();</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.10</a> on Wed Mar 23 2022 13:22:37 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
