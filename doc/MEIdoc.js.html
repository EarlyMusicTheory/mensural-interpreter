<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>MEIdoc.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="MEIdoc.html">MEIdoc</a><ul class='methods'><li data-type='method' style='display: none;'><a href="MEIdoc.html#addAnnotation">addAnnotation</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#addMeiElement">addMeiElement</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#addRevision">addRevision</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#appendToIdDictionary">appendToIdDictionary</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#doXPathOnDoc">doXPathOnDoc</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#getAnnotation">getAnnotation</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#getBlockByEventId">getBlockByEventId</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#getBlocksFromSections">getBlocksFromSections</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#initAnnotations">initAnnotations</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#initEventDict">initEventDict</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#preprocess">preprocess</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#proportionMultiplier">proportionMultiplier</a></li><li data-type='method' style='display: none;'><a href="MEIdoc.html#renewBlob">renewBlob</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="alterate.html">alterate</a><ul class='methods'><li data-type='method' style='display: none;'><a href="alterate.html#.firstBeatAlteration">firstBeatAlteration</a></li><li data-type='method' style='display: none;'><a href="alterate.html#.midBeatAlteration">midBeatAlteration</a></li><li data-type='method' style='display: none;'><a href="alterate.html#.secondBeatAlteration">secondBeatAlteration</a></li><li data-type='method' style='display: none;'><a href="alterate.html#.thirdBeatAlteration">thirdBeatAlteration</a></li><li data-type='method' style='display: none;'><a href="alterate.html#~checkForGeneralAlteration">checkForGeneralAlteration</a></li></ul></li><li><a href="basic.html">basic</a><ul class='methods'><li data-type='method' style='display: none;'><a href="basic.html#.beatIndependentDurations">beatIndependentDurations</a></li><li data-type='method' style='display: none;'><a href="basic.html#~actOnColoration">actOnColoration</a></li><li data-type='method' style='display: none;'><a href="basic.html#~actOnDots">actOnDots</a></li><li data-type='method' style='display: none;'><a href="basic.html#~allUnalterableImperfectLevels">allUnalterableImperfectLevels</a></li><li data-type='method' style='display: none;'><a href="basic.html#~anteSim">anteSim</a></li><li data-type='method' style='display: none;'><a href="basic.html#~labelRests">labelRests</a></li><li data-type='method' style='display: none;'><a href="basic.html#~simplestAlterations">simplestAlterations</a></li></ul></li><li><a href="complexBeats.html">complexBeats</a><ul class='methods'><li data-type='method' style='display: none;'><a href="complexBeats.html#.complexAnalysis">complexAnalysis</a></li><li data-type='method' style='display: none;'><a href="complexBeats.html#~afterTheEasyBits">afterTheEasyBits</a></li></ul></li><li><a href="durIO.html">durIO</a><ul class='methods'><li data-type='method' style='display: none;'><a href="durIO.html#.readBlockFrom">readBlockFrom</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.readDur">readDur</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.readDurGes">readDurGes</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.readStartsAt">readStartsAt</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.setBeatPos">setBeatPos</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.setBreveBoundaries">setBreveBoundaries</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.setDurGesPerBlock">setDurGesPerBlock</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.setStartsAt">setStartsAt</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.windowDuration">windowDuration</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeAlteration">writeAlteration</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeComment">writeComment</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeCommentById">writeCommentById</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeDur">writeDur</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeDurGes">writeDurGes</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeDurWithRule">writeDurWithRule</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeImperfection">writeImperfection</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writePerfection">writePerfection</a></li><li data-type='method' style='display: none;'><a href="durIO.html#.writeSimpleImperfection">writeSimpleImperfection</a></li><li data-type='method' style='display: none;'><a href="durIO.html#~breveDifference">breveDifference</a></li><li data-type='method' style='display: none;'><a href="durIO.html#~gcd">gcd</a></li></ul></li><li><a href="imperfect.html">imperfect</a><ul class='methods'><li data-type='method' style='display: none;'><a href="imperfect.html#.firstBeatImperfection">firstBeatImperfection</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#.midBeatImperfection">midBeatImperfection</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#.secondBeatImperfection">secondBeatImperfection</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#.thirdBeatImperfection">thirdBeatImperfection</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~canImperfect">canImperfect</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~divisionLikeRests">divisionLikeRests</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~firstBeatImperfectionCheck">firstBeatImperfectionCheck</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~imperfectingLevels">imperfectingLevels</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~indexOfNextDot">indexOfNextDot</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~indexOfNextSameOrLongerOrDot">indexOfNextSameOrLongerOrDot</a></li><li data-type='method' style='display: none;'><a href="imperfect.html#~solidBlock">solidBlock</a></li></ul></li><li><a href="ioHandler.html">ioHandler</a></li><li></li><li><a href="post.html">post</a><ul class='methods'><li data-type='method' style='display: none;'><a href="post.html#.run">run</a></li><li data-type='method' style='display: none;'><a href="post.html#~addAppInfo">addAppInfo</a></li><li data-type='method' style='display: none;'><a href="post.html#~addBarLines">addBarLines</a></li></ul></li><li><a href="rm.html">rm</a><ul class='methods'><li data-type='method' style='display: none;'><a href="rm.html#.augDot">augDot</a></li><li data-type='method' style='display: none;'><a href="rm.html#.beatUnitStructure">beatUnitStructure</a></li><li data-type='method' style='display: none;'><a href="rm.html#.divisionDot">divisionDot</a></li><li data-type='method' style='display: none;'><a href="rm.html#.dupleMinimCountFromElement">dupleMinimCountFromElement</a></li><li data-type='method' style='display: none;'><a href="rm.html#.firstPerfectLevel">firstPerfectLevel</a></li><li data-type='method' style='display: none;'><a href="rm.html#.isAlterable">isAlterable</a></li><li data-type='method' style='display: none;'><a href="rm.html#.isColored">isColored</a></li><li data-type='method' style='display: none;'><a href="rm.html#.isNote">isNote</a></li><li data-type='method' style='display: none;'><a href="rm.html#.leveleq">leveleq</a></li><li data-type='method' style='display: none;'><a href="rm.html#.mensurSummary">mensurSummary</a></li><li data-type='method' style='display: none;'><a href="rm.html#.minimStructures">minimStructures</a></li><li data-type='method' style='display: none;'><a href="rm.html#.noteInt">noteInt</a></li><li data-type='method' style='display: none;'><a href="rm.html#.noteOrRest">noteOrRest</a></li><li data-type='method' style='display: none;'><a href="rm.html#.notePerfectAsWhole">notePerfectAsWhole</a></li><li data-type='method' style='display: none;'><a href="rm.html#.regularlyPerfect">regularlyPerfect</a></li><li data-type='method' style='display: none;'><a href="rm.html#.simpleMinims">simpleMinims</a></li><li data-type='method' style='display: none;'><a href="rm.html#~noteIntFromDur">noteIntFromDur</a></li></ul></li><li><a href="startTimes.html">startTimes</a><ul class='methods'><li data-type='method' style='display: none;'><a href="startTimes.html#.addAllStartTimes">addAllStartTimes</a></li><li data-type='method' style='display: none;'><a href="startTimes.html#.addBreveBoundariesForBlock">addBreveBoundariesForBlock</a></li><li data-type='method' style='display: none;'><a href="startTimes.html#.addStartTimes">addStartTimes</a></li><li data-type='method' style='display: none;'><a href="startTimes.html#.addStartTimesForBlock">addStartTimesForBlock</a></li><li data-type='method' style='display: none;'><a href="startTimes.html#.updateBlocks">updateBlocks</a></li></ul></li><li><a href="vrvInterface.html">vrvInterface</a><ul class='methods'><li data-type='method' style='display: none;'><a href="vrvInterface.html#.applyZoom">applyZoom</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#.loadData">loadData</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#.nextPage">nextPage</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#.prevPage">prevPage</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#.zoomIn">zoomIn</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#.zoomOut">zoomOut</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#~bindInteractionEvents">bindInteractionEvents</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#~deselectEvent">deselectEvent</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#~loadPage">loadPage</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#~selectEvent">selectEvent</a></li><li data-type='method' style='display: none;'><a href="vrvInterface.html#~setOptions">setOptions</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#baseUrl">baseUrl</a></li><li><a href="global.html#basicAnalysisDone">basicAnalysisDone</a></li><li><a href="global.html#checkIfAlreadyRun">checkIfAlreadyRun</a></li><li><a href="global.html#complexAnalysisDone">complexAnalysisDone</a></li><li><a href="global.html#currentParams">currentParams</a></li><li><a href="global.html#currentUrl">currentUrl</a></li><li><a href="global.html#evaluateResults">evaluateResults</a></li><li><a href="global.html#fetchMEI">fetchMEI</a></li><li><a href="global.html#getProperty">getProperty</a></li><li><a href="global.html#getPropertyByID">getPropertyByID</a></li><li><a href="global.html#getSectionBlocks">getSectionBlocks</a></li><li><a href="global.html#hideDetails">hideDetails</a></li><li><a href="global.html#highlightQualities">highlightQualities</a></li><li><a href="global.html#instructor">instructor</a></li><li><a href="global.html#interpreter">interpreter</a></li><li><a href="global.html#intResp">intResp</a></li><li><a href="global.html#isRest">isRest</a></li><li><a href="global.html#loadData">loadData</a></li><li><a href="global.html#makeXmlCode">makeXmlCode</a></li><li><a href="global.html#meiFile">meiFile</a></li><li><a href="global.html#nextEvent">nextEvent</a></li><li><a href="global.html#prevEvent">prevEvent</a></li><li><a href="global.html#selectAdjacentElByID">selectAdjacentElByID</a></li><li><a href="global.html#setProperty">setProperty</a></li><li><a href="global.html#setPropertyByID">setPropertyByID</a></li><li><a href="global.html#showDetails">showDetails</a></li><li><a href="global.html#shownEvent">shownEvent</a></li><li><a href="global.html#submitFeedback">submitFeedback</a></li><li><a href="global.html#updateBlob">updateBlob</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">MEIdoc.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

/**
 * @fileoverview This file contains the MEIdoc class
 * 
 * Trying to fake some kind of private scope for the class.
 * Used https://blog.bitsrc.io/doing-it-right-private-class-properties-in-javascript-cc74ef88682e
 * 
 */

/**
 * @namespace MEIdoc
 * @desc Contains MEIdoc class and private MEIdoc functions
 */
var MEIdoc = (() => {
    const parser = new DOMParser();
    const serializer = new XMLSerializer();

	/**
	 * Return all the sections that themselves contain no sections (we
	 * have a hierarchical tree structure for parts, so this only chooses
	 * the lowest level structural unit.
	 * @param {DOMObject} MEIDoc 
	 * @return {Array} Array of mei:section elements
	 * @see easyRhythms
	 */ 
	function getAtomicSections(MEIDoc){
		let sections = MEIDoc.getElementsByTagName('section');
		return Array.from(sections).filter(hasNoSections, MEIDoc);
	}

	/**
	 * Return true if x (an XML DOM object, normally MEI) contains *no*
	 * mei:sections. this needs to be set as a DOM document object.
	 * @param {DOMObject} x - the part of the tree.  
	 * @return {Boolean} 
	 */
	function hasNoSections(x){
		if(this.evaluate){
			return x.childElementCount!==0 &amp;&amp; this.evaluate('count(mei:section)', x, nsResolver).numberValue===0;
		} else {
			return x.childElementCount!==0 &amp;&amp; !x.getElementsByTagName('section').length;
		}
	}

	/**
	 * Return all layers for a section
	 * @param {DOMObject} section 
	 * @return {Array} Array of mei:layer elements 
	 */
	function getLayers(section){
		let sections = section.getElementsByTagName('layer');
		return Array.from(sections);
	}

	/**
	 * Creates an array of mensurally coherent blocks, each an object with
	 * mensuration and events attributes.
	 * @param {DOMObject} section The section to process
	 * @param {MEIdoc} meiDoc The parent MEI doc object
	 * @param {Object} prevMens The last mensuration of the previous block
	 * (this is the default for the first section of hte new block in some
	 * cases, if none is specified).
	 * @param {string} partNum Number of staff
	 * @return {Array&lt;Object>} Array of mensurally coherent blocks
	 */
	function getEventsByMensurationForSection(section, meiDoc, prevMens, partNum){
		if(meiDoc.doc.createNodeIterator){
			var ni = meiDoc.doc.createNodeIterator(section, NodeFilter.SHOW_ELEMENT);
			var next = ni.nextNode();
		} else {
			var bucket = section.getElementsByTagName('*');
			var pointer = 0;
			var next = bucket[pointer];
		}
		var foo = [];
		var block = {part: partNum, mens: prevMens, events: foo, prevPropMultiplier: 1};
		// Assumed defaults (changed if evidence to the contrary)
		block.mens.setAttributeNS(null, 'modusmaior', 2);
		block.mens.setAttributeNS(null, 'modusminor', 2);
		var blocks = [block];
		var count2b = 0;
		var count3b = 0;
		while(next){
			if(next.tagName!=='rest')
			{
				if(block.mens)
				{
					if(count2b===2 || count3b===2) block.mens.setAttributeNS(null, 'modusmaior', 2);
					if(count2b===3 || count3b===3) block.mens.setAttributeNS(null, 'modusmaior', 3);
				}
				count2b = 0;
				count3b = 0;
			}
						
			switch(next.tagName){
				case 'mensur':
					if(foo.length){
						foo = [];
						let num = next.getAttribute("num");
						let numbase = next.getAttribute("numbase");
						let propMultiplier = (num &amp;&amp; numbase) ? propProportionMultiplier(next) : 1;
						block = {part: partNum,
								mens:next, 
								prevPropMultiplier: propMultiplier,
								events: foo};
						blocks.push(block);
					} else {
						block.mens = next;
					}
					// Assumed defaults (changed if evidence to the contrary)
					if(!next.getAttributeNS(null, 'modusmaior')) block.mens.setAttributeNS(null, 'modusmaior', 2);
					if(!next.getAttributeNS(null, 'modusminor')) block.mens.setAttributeNS(null, 'modusminor', 2);
					break
				case 'proport':
					if(foo.length){
						foo = [];
						block = {part: partNum,
								mens:block.mens, 
								prop:next, 
								events: foo, 
								prevPropMultiplier: propProportionMultiplier(next)};
						blocks.push(block);
					} else {
						block.prop = next;
					}
					break				
				case 'rest':
					if(block.mens){
						if(next.getAttributeNS(null, 'dur')==='2B'){
							count2b++;
							block.mens.setAttributeNS(null, 'modusminor', 2);
						} 
						else if (next.getAttributeNS(null, 'dur')==='3B'){
							count3b++;
							block.mens.setAttributeNS(null, 'modusminor', 3);
						}
					}
				case 'note':
				case 'dot':
					foo.push(next);
					meiDoc.appendToIdDictionary(next.getAttributeNS(null, "id"), block)
                    //idDictionary[next.getAttributeNS(null, "id")] = block;
			}
			if(ni){
				next = ni.nextNode();
			} else {
				pointer++;
				next = pointer &lt; bucket.length ? bucket[pointer]: false;
			}
		}
		return blocks	
	}

	/** 
	 * Name space manager function. Takes a prefix and returns the URL for
	 * that name space. In this case, though, pretty much hard-wired.
	 * @param {String} prefix The namespace prefix to retrieve as a URL
	 */
	function nsResolver(prefix){
		var ns = {
		'mei': "http://www.music-encoding.org/ns/mei"
		}
		return ns[prefix] || null;
	}

    /**
	 * Given a proportion-specifying element, give its implied multiplier
	 * @param {DOMObject} el proportion element
     * @returns {Number}
     */
    function propProportionMultiplier(el) {
        var num = el.getAttributeNS(null, 'num') || 1;
        var div = el.getAttributeNS(null, 'numbase') || 1;
        return Number(num) / Number(div);
    }
    

    /**
     * @class
     */
    class MEIdoc {
		/**
		 * @constructs MEIdoc
		 * @param {string} meiText 
		 */
        constructor(meiText) {
            this.meiDoc = meiText ? parser.parseFromString(meiText, "text/xml") : null;
			this.idDict = {};
			this.eventIdDict = {};
            this.sectionBlocks;
			this.annots = {};
			if(this.doc) this.initEventDict();
			this.meiBlob = this.meiDoc ? new Blob([this.text], {type: 'text/xml'}) : null;
			if(this.doc) this.getBlocksFromSections();
        }

		/**
		 * @property {string} text
		 */
        get text() {
            return this.doc ? serializer.serializeToString(this.doc) : null;
        }
        set text(meiText) {
            this.doc = parser.parseFromString(meiText, "text/xml");
			if (this.doc) this.getBlocksFromSections();
        }

		/** @property {DOMObject} doc */
        get doc() {
            return this.meiDoc ? this.meiDoc : null;
        }
        set doc(meiDocTree) {
            this.meiDoc = meiDocTree;
			this.preprocess();
			if(this.meiDoc) this.getBlocksFromSections();
			if(this.meiDoc) this.initEventDict();
			if(this.meiDoc) this.initAnnotations();
			if(this.meiDoc) this.meiBlob = new Blob([this.text], {type: 'text/xml'});
        }

		/**
		 * @property {Blob} blob
		 */
		get blob() {
			return this.meiBlob;
		}
		/**
		 * renew the blob after changes on the document tree
		 */
		renewBlob() {
			this.meiBlob = new Blob([this.text], {type: 'text/xml'});
		}

		/**
		 * @property {Array&lt;Object>} blocks Mensurally coherent blocks
		 */
        get blocks() {
            return this.sectionBlocks;
        }
        set blocks(blockArray) {
            this.sectionBlocks = blockArray;
        }

		/**
		 * @property {Object.&lt;string,Object>} idDictionary return block by event id
		 */
        get idDictionary() {
            return this.idDict;
        }
        set idDictionary(idDictObj) {
            this.idDict = idDictObj;
        }
		/**
		 * Adds an entry to the idDictionary
		 * @param {String} id 
		 * @param {Object} block 
		 */
        appendToIdDictionary(id, block) {
            this.idDict[id] = block;
        }
		/**
		 * Retrieves a block via the xml:id of one of its events
		 * @param {String} eventId 
		 * @returns {Object} block
		 */
        getBlockByEventId(eventId) {
            return this.idDictionary[eventId];
        }

		/**
		 * @property {Object.&lt;string,Object>} eventDict id to xml element
		 */
		get eventDict () {
			return this.eventIdDict;
		}

		/**
		 * builds a dictionary to access an element via its xml:id
		 */
		initEventDict()  {
			var bucket = this.doc.getElementsByTagName('*');
			for (let element of bucket)
			{
				let id;
				if(element.getAttribute("xml:id"))
				{
					id = element.getAttribute("xml:id");
				}
				else
				{
					element.setAttribute("xml:id", "ID" + uuidv4());
					id = element.getAttribute("xml:id");
				}
				
				this.eventIdDict[id] = element;
			}
		}
		
		/**
		 * Creates a new mei element with the given name and registers
		 * it in the eventDict.
		 * @param {string} elName 
		 * @returns {DOMElement} created element
		 */
		addMeiElement(elName, id) {
			let el = this.doc.createElementNS(nsResolver("mei"), elName);
			if (!id)
			{
				id = "ID" + uuidv4();
			}
			el.setAttribute("xml:id", id);
			this.eventIdDict[id] = el;

			return el;
		}

		/** @property {Object.&lt;string,Object>} annotations event id to annotations */
		get annotations () {
			return this.annots;
		}

		/**
		 * Initializes the annotations dictionary of the current MEI file.
		 */
		initAnnotations() {
			var annotationsFromFile = this.doXPathOnDoc("//mei:annot[@type='" + interpreter + "']", this.doc, 5);

			var loadedAnnotation = annotationsFromFile.iterateNext();

			while(loadedAnnotation)
			{
				let eventID = loadedAnnotation.getAttribute("startid").substring(1);
				this.annots[eventID] = loadedAnnotation;
				loadedAnnotation = annotationsFromFile.iterateNext();
			}
		}

		/**
		 * Retrieves the annotation control event for the event with the given id.
		 * @param {string} eventID xml:id of MEI event
		 * @returns {DOMElement} &lt;annot>
		 */
		getAnnotation (eventID) {
			return this.annotations[eventID];
		}
		/**
		 * Creates an interpreter-related annotation about a certain element.
		 * @param {string} eventID 
		 * @returns {Element} newly created annot
		 */
		addAnnotation (eventID) {
			let annot = this.addMeiElement("annot");
			annot.setAttribute("startid", "#" + eventID);
			annot.setAttribute("type", interpreter);
			annot.setAttribute("audience", "private");

			let staff = this.doc.evaluate("./ancestor::mei:staff[1]", this.eventDict[eventID], nsResolver, 9).singleNodeValue;

			staff.appendChild(annot);

			this.annots[eventID] = annot;
			return annot;
		}

		/** non-property related methods */
        
		/**
		 * Build mensurally coherent blocks from current document
		 */
        getBlocksFromSections() {
			var sections = getAtomicSections(this.doc);
			var layers = []; 
			var sectionBlocks = [];
			//var layerMens = [];

			for (let i of sections)
			{
				let currentLayers = getLayers(i);
				currentLayers.forEach(layer => layers.push(layer));
			}

			var prevPartNum = "0";
			for (let i of layers)
			{
				let staffNum = i.parentElement.getAttribute("n");
				let prevMens = false;
				if(prevPartNum !== staffNum)
				{
					prevMens = this.doXPathOnDoc("//mei:staffDef[@n='"+staffNum+"']/mei:mensur",i,9).singleNodeValue;
				}
				else
				{
					prevMens = sectionBlocks[sectionBlocks.length - 1].mens;
				}
				let layerBlocks = getEventsByMensurationForSection(i, this, prevMens, staffNum);
				//layerMens[i] = layerBlocks[layerBlocks.length - 1].mens;
				layerBlocks.forEach(lBlocks => sectionBlocks.push(lBlocks));
				prevPartNum = staffNum;
			}

			this.blocks = sectionBlocks;
		}

        /**
         * Given a block index number, finds the proportion of that block and returns the factor.
		 * @param {integer} blockIndex mei:note or mei:rest
         * @returns {Number} 
         */
        proportionMultiplier(blockIndex){
            let block = this.blocks[blockIndex];
            // if(block.prop) console.log("so", blockProportionMultiplier(block));
            // return blockProportionMultiplier(block);
            if(block.prop){
                if(block.prop.getAttributeNS(null, 'multiplier')){
                    return Number(block.prop.getAttributeNS(null, 'multiplier'));
                } else {
                    return propProportionMultiplier(block.prop);
                }
            } else return 1;
        }

		/**
		 * Adds a revision to the MEIhead at the current date
		 * @param {string} resp URI to responsible agent
		 * @param {string} text change description
		 */
		addRevision(resp, text) {
			var revisionDesc = this.doXPathOnDoc("//mei:revisionDesc", meiFile.doc, 9).singleNodeValue;

			let checkForExistingChange = "//mei:change[@resp='" + resp + 
                                    "' and .//mei:p[contains(text(),'" + text + "')]]";
			var existingChange = meiFile.doXPathOnDoc(checkForExistingChange, revisionDesc, 9).singleNodeValue;
			var date = new Date();
			if(existingChange==null)
			{  
				// add change as last child
				var change = meiFile.addMeiElement("change");
				revisionDesc.append(change);
				// add isodate and resp
				change.setAttribute("resp", resp);
				change.setAttribute("isodate", date.toISOString());
				// add changeDesc and p
				let p = meiFile.addMeiElement("p");
				p.textContent = text;
				let changeDesc = meiFile.addMeiElement("changeDesc");
				changeDesc.append(p);
				change.append(changeDesc);
			}
			else
			{
				if(!existingChange.attributes["startdate"])
				{
					existingChange.setAttribute("startdate", existingChange.getAttribute("isodate"));
				}
				existingChange.setAttribute("isodate", date.toISOString());
			}
		}

		/**
		 * Preprocesses MEI file as a matter or normalization
		 * * merge adjacent &lt;mensur> and &lt;proport> into &lt;mensur> (to keep them together and avoid Verovio strangeness?)
		 * 	 @todo adjust blockification
		 * * put first &lt;clef> and &lt;keySig> into &lt;staffDef>
		 * * @todo maybe: delete empty &lt;dir>
		 * * @todo maybe: delete empty &lt;verse>
		 * * delete note/@lig if it is identical to ligature/@form
		 */
		preprocess(){
			
			// add revisionDesc if not available
			var meiHead = this.doXPathOnDoc("//mei:meiHead", this.doc, 9).singleNodeValue;
			var revisionDesc = meiHead.getElementsByTagName("revisionDesc")[0];
			if(!revisionDesc)
			{
				revisionDesc = this.addMeiElement("revisionDesc");
				meiHead.append(revisionDesc);
			}

			// clean up for every staff
			for(let staff of this.doc.getElementsByTagName("staff") )
			{
				//tidyClefKeySig(staff, this.doc);
				mergeAdjacentMensProp(staff);
				//putStartingMensToStaffDef(staff, this.doc)
				removeLig(staff);
			}

			// clean up only for first staffs per staffDef
			let staffNumIterator = this.doXPathOnDoc("//mei:staffDef/@n", this.doc, 5);
			let currentStaffNum = staffNumIterator.iterateNext();
			let staffNums = [];
			while(currentStaffNum)
			{
				staffNums.push(currentStaffNum.value);
				currentStaffNum = staffNumIterator.iterateNext();
			}
			for(let staffNum of staffNums)
			{
				let firstStaff = this.doXPathOnDoc("//mei:staff[@n='"+staffNum+"'][1]", this.doc, 5).iterateNext();
				tidyClefKeySig(firstStaff, this.doc);
				putStartingMensToStaffDef(firstStaff, this.doc);
			}
		}

		/**
		 * A convenient way to pipe XPath queries to the meiDoc.
		 * Uses the internal ns-resolver.
		 * @param {string} expression XPath expression
		 * @param {DOMElement|Document} context context element or document
		 * @param {integer} resultType https://developer.mozilla.org/en-US/docs/Web/API/Document/evaluate#result_types
		 * @returns {XPathResult} result
		 */
		doXPathOnDoc(expression, context, resultType)
		{
			return this.doc.evaluate(expression, context, nsResolver, resultType);
		}
        
    }  

	// preprocessing functions
	/**
	 * If a staff starts with clef and keySig, move it to the staffDef
	 * @param {DOMElement} staffElement 
	 * @param {Document} doc
	 */
	function tidyClefKeySig(staffElement, doc)
	{
		let staffNum = staffElement.getAttribute("n");
		let staffDef = doc.evaluate("//mei:staffDef[@n='"+staffNum+"']", doc.childNodes[0], nsResolver).iterateNext();
		if(doc.evaluate('./mei:layer/mei:clef', staffElement, nsResolver, 3).booleanValue &amp;&amp;
			doc.evaluate('count(./mei:layer/mei:clef[1]/preceding-sibling::mei:note)', staffElement, nsResolver).numberValue === 0)
		{
			let firstClef = staffElement.getElementsByTagName("clef")[0];
			staffDef.appendChild(firstClef);
		}
		
		if(doc.evaluate('./mei:layer/mei:keySig', staffElement, nsResolver, 3).booleanValue &amp;&amp;
			doc.evaluate('count(./mei:layer/mei:keySig[1]/preceding-sibling::mei:note)', staffElement, nsResolver).numberValue === 0)
		{
			let firstKeySig = staffElement.getElementsByTagName("keySig")[0];
			staffDef.appendChild(firstKeySig);
		}
	}


	/**
	 * Gather first mensuration of a staff as &lt;mensur> child element of staffDef
	 * @param {DOMElement} staffElement 
	 * @param {Document} doc
	 */
	function putStartingMensToStaffDef(staffElement, doc)
	{
		let staffNum = staffElement.getAttribute("n");
		let staffDef = doc.evaluate("//mei:staffDef[@n='"+staffNum+"']", doc.childNodes[0], nsResolver).iterateNext();
		let mensAttrStartList = ["mensur.", "poport.", "tempus", "prolatio", "modusminor", "modusmaior"];

		if(doc.evaluate('./mei:layer/mei:mensur', staffElement, nsResolver, 3).booleanValue &amp;&amp;
			doc.evaluate('count(./mei:layer/mei:mensur[1]/preceding-sibling::mei:note)', staffElement, nsResolver).numberValue === 0)
		{
			let firstMensur = staffElement.getElementsByTagName("mensur")[0];
			staffDef.appendChild(firstMensur);
		}
		else if(doc.evaluate('./@tempus and ./@prolatio', staffDef, nsResolver, 3).booleanValue)
		{
			let mensur = doc.createElementNS(nsResolver("mei"), "mensur");
			let staffDefAttrs = staffDef.attributes;

			// because attributes get removed, start iterating from back to front
			for (let a = staffDefAttrs.length-1; a >= 0; a--)
			{
				let attr = staffDefAttrs[a];
				for (let listItem of mensAttrStartList)
				{
					if (attr.name.startsWith(listItem))
					{
						// "mensur." and "proport." needs to be removed within &lt;mensur>
						// let's do some regex to cut everything to the dot
						let attrName = attr.name.replace(/^[\w+]*\./,'');
						mensur.setAttribute(attrName, attr.value);
						staffDef.removeAttribute(attr.name);
					}
				}
			}
			staffDef.appendChild(mensur);
		}
	}

	/**
	 * Should remove redundant ligature form and note lig attributes.
	 * For now, ligatures will be removed completely for better alignment
	 * @todo Remove just redundant visual attributes when Verovio rendering is properly done
	 * @param {DOMElement} staffElement 
	 */
	function removeLig(staffElement)
	{
		let layers = staffElement.getElementsByTagName("layer");
		for (let layer of layers)
		{
			let ligatures = layer.getElementsByTagName("ligature");
			for (let i = ligatures.length -1; i >= 0; i--)
			{
				let ligature = ligatures[i];
				for (let event of ligature.children)
				{
					// we create a copy to loop properly
					// counting backwards would cause more trouble 
					// when getting the order of the notes right
					let copyEvent = event.cloneNode(true);
					if(copyEvent.getAttribute("lig")) copyEvent.removeAttribute("lig");
					layer.insertBefore(copyEvent,ligature);
				}
				ligature.remove();
			}
		}
	}

	/**
	 * Adjacent &lt;mensur> &lt;proport> elements get merged into one &lt;mensur> element
	 * (avoids misplacments in rendering)
	 * @param {DOMElement} staffElement 
	 */
	function mergeAdjacentMensProp(staffElement)
	{
		let mensuration = staffElement.getElementsByTagName("mensur");
		for (let mens of mensuration)
		{
			if (mens.nextElementSibling.tagName==="proport")
			{
				let prop = mens.nextElementSibling;
				mens.setAttribute("num",prop.getAttribute("num"));
				mens.setAttribute("numbase",prop.getAttribute("numbase"));
				prop.remove();
			}
		}
	}

    return MEIdoc;
  })();


</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.10</a> on Wed Mar 09 2022 09:29:25 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
